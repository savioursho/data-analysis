{
  "hash": "2e8720d57e974152dba329933f5b1231",
  "result": {
    "markdown": "# 特徴量エンジニアリング\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport polars as pl\nimport seaborn as sns\nsns.set_theme(style=\"whitegrid\")\n```\n:::\n\n\n## 数値特徴量の和と差\n\n### 境界が $y = -x$ のとき\n\n境界は $y = -x$ つまり、\n$y + x = 0$ であるから、\n$y + x$ という特徴量を作成することで、\n境界が軸に沿うようになり、\n決定木での分離が用意になる。\nそのことを以下で見ていく。\n\n\n格子点のデータを作成。\n$y = -x$ を境にクラスを分ける。\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nx = np.linspace(-5, 5)\ny = np.linspace(-5, 5)\n\nx_mesh, y_mesh = np.meshgrid(x, y)\n\ndf = pl.DataFrame({\n    \"X\":x_mesh.ravel(),\n    \"Y\":y_mesh.ravel(),\n})\n\ndf = df.with_column(\n    (pl.col(\"Y\") > (- pl.col(\"X\"))).cast(pl.UInt8).alias(\"target\")\n)\ndf.head()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/tmp/ipykernel_7617/451670805.py:11: DeprecationWarning: `with_column` has been deprecated in favor of `with_columns`. This method will be removed in version 0.17.0\n  df = df.with_column(\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style>\n.pl-dataframe > thead > tr > th {\n  text-align: right;\n}\n</style>\n\n<table border=\"1\" class=\"pl-dataframe\">\n<small>shape: (5, 3)</small>\n<thead>\n<tr>\n<th>\nX\n</th>\n<th>\nY\n</th>\n<th>\ntarget\n</th>\n</tr>\n<tr>\n<td>\nf64\n</td>\n<td>\nf64\n</td>\n<td>\nu8\n</td>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n-5.0\n</td>\n<td>\n-5.0\n</td>\n<td>\n0\n</td>\n</tr>\n<tr>\n<td>\n-4.795918\n</td>\n<td>\n-5.0\n</td>\n<td>\n0\n</td>\n</tr>\n<tr>\n<td>\n-4.591837\n</td>\n<td>\n-5.0\n</td>\n<td>\n0\n</td>\n</tr>\n<tr>\n<td>\n-4.387755\n</td>\n<td>\n-5.0\n</td>\n<td>\n0\n</td>\n</tr>\n<tr>\n<td>\n-4.183673\n</td>\n<td>\n-5.0\n</td>\n<td>\n0\n</td>\n</tr>\n</tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n可視化\n\n::: {.cell .fig-cap-location-margin execution_count=3}\n``` {.python .cell-code code-fold=\"true\"}\nsns.relplot(\n    data=df,\n    x=\"X\",\n    y=\"Y\",\n    hue=\"target\",\n    palette=\"tab10\",\n    s=10,\n);\n```\n\n::: {.cell-output .cell-output-display}\n![$y = -x$ を境に正解のクラスが変わるデータ。境界が軸に対して斜めであるため、決定木では深さが必要となる。](index_files/figure-commonmark/fig-1-output-1.png){#fig-1}\n:::\n:::\n\n\n和と差を計算する\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndf = df.with_columns([\n    (pl.col(\"X\") + pl.col(\"Y\")).alias(\"X+Y\"),\n    (pl.col(\"X\") - pl.col(\"Y\")).alias(\"X-Y\"),\n])\n```\n:::\n\n\n可視化\n\n::: {.cell .fig-cap-location-margin execution_count=5}\n``` {.python .cell-code code-fold=\"true\"}\nsns.relplot(\n    data=df.melt([\"X\", \"Y\", \"target\"]),\n    x=\"X\",\n    y=\"value\",\n    col=\"variable\",\n    hue=\"target\",\n    palette=\"tab10\",\n    s=10,\n);\n```\n\n::: {.cell-output .cell-output-display}\n![左は縦軸を`X+Y`にしたもの。右は縦軸を`X=Y`にしたもの。和 `X+Y` と元の変数 `X` の2次元では、境界が軸に沿っているので、深さ1の決定木でほぼ分離できる。差`X=Y` と`X`の2次元では、境界が軸に沿っていないので、決定木の深さが必要となる。](index_files/figure-commonmark/fig-2-output-1.png){#fig-2}\n:::\n:::\n\n\n::: {.cell .fig-cap-location-margin execution_count=6}\n``` {.python .cell-code code-fold=\"true\"}\nsns.relplot(\n    data=df,\n    x=\"X+Y\",\n    y=\"X-Y\",\n    hue=\"target\",\n    palette=\"tab10\",\n    s=10,\n);\n```\n\n::: {.cell-output .cell-output-display}\n![`X+Y` と `X-Y` の2次元では元の `X` と `Y` のデータを回転（と定数倍）した形になる。境界が軸に沿っているので、深さ1の決定木でほぼ分離できる。](index_files/figure-commonmark/fig-3-output-1.png){#fig-3}\n:::\n:::\n\n\n### 境界が $y = 2 \\sin (x)$ のとき\n\nデータ作成\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nx = np.linspace(-5, 5)\ny = np.linspace(-5, 5)\n\nx_mesh, y_mesh = np.meshgrid(x, y)\n\ndf = pl.DataFrame({\n    \"X\":x_mesh.ravel(),\n    \"Y\":y_mesh.ravel(),\n})\n\ndf = df.with_column(\n    (pl.col(\"Y\") > 2 * np.sin(pl.col(\"X\"))).cast(pl.UInt8).alias(\"target\")\n)\ndf.head()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/tmp/ipykernel_7617/352439095.py:11: DeprecationWarning: `with_column` has been deprecated in favor of `with_columns`. This method will be removed in version 0.17.0\n  df = df.with_column(\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style>\n.pl-dataframe > thead > tr > th {\n  text-align: right;\n}\n</style>\n\n<table border=\"1\" class=\"pl-dataframe\">\n<small>shape: (5, 3)</small>\n<thead>\n<tr>\n<th>\nX\n</th>\n<th>\nY\n</th>\n<th>\ntarget\n</th>\n</tr>\n<tr>\n<td>\nf64\n</td>\n<td>\nf64\n</td>\n<td>\nu8\n</td>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n-5.0\n</td>\n<td>\n-5.0\n</td>\n<td>\n0\n</td>\n</tr>\n<tr>\n<td>\n-4.795918\n</td>\n<td>\n-5.0\n</td>\n<td>\n0\n</td>\n</tr>\n<tr>\n<td>\n-4.591837\n</td>\n<td>\n-5.0\n</td>\n<td>\n0\n</td>\n</tr>\n<tr>\n<td>\n-4.387755\n</td>\n<td>\n-5.0\n</td>\n<td>\n0\n</td>\n</tr>\n<tr>\n<td>\n-4.183673\n</td>\n<td>\n-5.0\n</td>\n<td>\n0\n</td>\n</tr>\n</tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n可視化\n\n::: {.cell .fig-cap-location-margin execution_count=8}\n``` {.python .cell-code code-fold=\"true\"}\nsns.relplot(\n    data=df,\n    x=\"X\",\n    y=\"Y\",\n    hue=\"target\",\n    palette=\"tab10\",\n    s=10,\n);\n```\n\n::: {.cell-output .cell-output-display}\n![$y = 2 \\sin(x)$ を境に正解のクラスが変わるデータ。](index_files/figure-commonmark/fig-4-output-1.png){#fig-4}\n:::\n:::\n\n\n特徴量作成\n\n$z = y - 2 \\sin(x)$ とする。\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndf = df.with_column(\n    (pl.col(\"Y\") - 2 * np.sin(pl.col(\"X\"))).alias(\"Z\")\n)\ndf.head()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/tmp/ipykernel_7617/1613510475.py:1: DeprecationWarning: `with_column` has been deprecated in favor of `with_columns`. This method will be removed in version 0.17.0\n  df = df.with_column(\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style>\n.pl-dataframe > thead > tr > th {\n  text-align: right;\n}\n</style>\n\n<table border=\"1\" class=\"pl-dataframe\">\n<small>shape: (5, 4)</small>\n<thead>\n<tr>\n<th>\nX\n</th>\n<th>\nY\n</th>\n<th>\ntarget\n</th>\n<th>\nZ\n</th>\n</tr>\n<tr>\n<td>\nf64\n</td>\n<td>\nf64\n</td>\n<td>\nu8\n</td>\n<td>\nf64\n</td>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\n-5.0\n</td>\n<td>\n-5.0\n</td>\n<td>\n0\n</td>\n<td>\n-6.917849\n</td>\n</tr>\n<tr>\n<td>\n-4.795918\n</td>\n<td>\n-5.0\n</td>\n<td>\n0\n</td>\n<td>\n-6.993027\n</td>\n</tr>\n<tr>\n<td>\n-4.591837\n</td>\n<td>\n-5.0\n</td>\n<td>\n0\n</td>\n<td>\n-6.985485\n</td>\n</tr>\n<tr>\n<td>\n-4.387755\n</td>\n<td>\n-5.0\n</td>\n<td>\n0\n</td>\n<td>\n-6.895535\n</td>\n</tr>\n<tr>\n<td>\n-4.183673\n</td>\n<td>\n-5.0\n</td>\n<td>\n0\n</td>\n<td>\n-6.726911\n</td>\n</tr>\n</tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.cell .fig-cap-location-margin execution_count=10}\n``` {.python .cell-code code-fold=\"true\"}\nsns.relplot(\n    data=df,\n    x=\"X\",\n    y=\"Z\",\n    hue=\"target\",\n    palette=\"tab10\",\n    s=10,\n);\n```\n\n::: {.cell-output .cell-output-display}\n![$z = y - 2 \\sin(x)$ を特徴量として作成することで、境界が軸に沿うようになった。](index_files/figure-commonmark/fig-5-output-1.png){#fig-5}\n:::\n:::\n\n\n",
    "supporting": [
      "index_files/figure-commonmark"
    ],
    "filters": []
  }
}